'use strict';
/** Transform the input of a multi-line string containing the two boards
 *  in ascii to two sets of board as double-arrays.
 * 
 * Returns: [ 
 *      [title, board_input, board_expected], 
 *      ...
 * ]
 */
function extract_input_output_boards(string_board)
{
    let boards_to_test = [];
    let idx = 0;
    while (idx < string_board.length) {
        let title = string_board[idx++];
        let two_boards_desc = string_board[idx++];
        console.log(title, two_boards_desc);
        let two_boards = extract_two_boards_from_string(two_boards_desc);
        boards_to_test.push([title, two_boards[0], two_boards[1]]);
    }

    return boards_to_test;
}

const ELT_TAB = 'abcdefghijk';

/** Returns two boards from a multi-line string board

Example:
`
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
..aaa.    ..b...

`

=> 
[
    [
        [-1, -1, -1, -1, -1, -1],
        ... (repeated 5 times)
        [-1, -1, 0, 0, -1, -1],
    ],
    [
        [-1, -1, -1, -1, -1, -1],
        ... (repeated 5 times)
        [-1, -1, 1, -1, -1, -1],
    ],
]
*/
function extract_two_boards_from_string(two_boards_desc)
{
    let board1 = [], board2 = [];
    let lines = two_boards_desc.split('\n');
    for (let i=0; i<lines.length; i++) {
        let l = lines[i].replace(' ', '');

        // skip empty lines
        if (l.length === 0) {
            continue;
        }

        let parts = l.split(/\s+/);
        let b1_line = parts[0];
        let b2_line = parts[1];

        let b1_board_line = Array.from(b1_line, (c) => ELT_TAB.indexOf(c));
        let b2_board_line = Array.from(b2_line, (c) => ELT_TAB.indexOf(c));

        board1.push(b1_board_line);
        board2.push(b2_board_line);
    }

    return [board1, board2];
}

/** Return a board updated with one combination 
 * 
 * board: Array of lines, each line is an array of element number
 * output: Array of lines, each line is an array of element number
 * */
function updated_board(input)
{
    let transmutations = calc_transmutations(input);
    return apply_transmutations(input, transmutations);
}

/** Returns number ranging from start to stop-1 */
function na3_range(start, stop)
{
    return Array.from(Array(stop-start).keys(), (i) => (i+start));
}

/** Analyse the board and returns the list of transmutation on this board
 * 
 * A transmutation is: [ old_elements, new_element ]
 * - old_elements is a list of [row, col]
 * - new_element  is [row, col, element]
 */
function calc_transmutations(input)
{
    let transmutations = [];

    // examine each horizontal line. If it contains 3 or more same elements, generate a transmutation
    for (let row=0; row<input.length; row++) {
        let last_elt = -2;
        let nb_same = 0;
        let line = input[row];
        let col;    // we want variable col to escape the loop
        function trans_push_if_necessary() {
            if (last_elt >= 0 && last_elt+1<ELT_TAB.length && nb_same+1 >= 3) {
                transmutations.push([
                    Array.from(na3_range(col-nb_same-1, col), (c) => [row, c]),
                    [row, col-nb_same-1, last_elt+1]
                ]);
            }
        }
        for (col=0; col<line.length; col++) {
            if (line[col] === last_elt) {
                nb_same += 1;
            } else {
                trans_push_if_necessary();
                nb_same = 0;
            }
            last_elt = line[col];
        }
        trans_push_if_necessary();
    }

    console.log('transmutations:', transmutations);
    return transmutations;
}


/** Apply a given a list of transmutation to a board and return the updated board */
function apply_transmutations(input, transmutations)
{
    console.log(input, transmutations);
    let output = Array.from(input, (line) => line.slice());
    transmutations.forEach((trans) => {
        let old_elt = trans[0];
        let new_elt = trans[1];
        old_elt.forEach((pos) => { output[pos[0]][pos[1]] = -1; });
        output[new_elt[0]][new_elt[1]] = new_elt[2];
    });
    return output;    
}


/***********************************************************************
 * 
 * This is all our test data to make sure we assemble elements correctly
 * 
 ***********************************************************************/

let na3_data = [
'1 combination - 1 element - 1', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......

`,'1 combination - 1 element - 2', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
..a...    ..a...


`,'1 combination - 3 elements - height 1 - 1', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
aaa...    b.....


`,'1 combination - 3 elements - height 1 - 2', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
..aaa.    ..b...

`,'1 combination - 3 elements - height 1 - 3', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
..aa.a    ..aa.a


`,'1 combination - 3 elements - height 1 - 4', `
......    ......
......    ......
......    ......
......    ......
......    ......
...aaa    ...b..
..ccdd    ..ccdd



`,'1 combination - 3 elements - height 2 - 1', `
......    ......
......    ......
......    ......
......    ......
......    ......
a.....    ......
aa....    b.....


`,'1 combination - 3 elements - height 2 - 2', `
......    ......
......    ......
......    ......
......    ......
......    ......
..cac.    ..c.c.
..aac.    ..b.c.


`,'1 combination - 3 elements - height 1 - 3', `
......    ......
......    ......
......    ......
......    ......
......    ......
..aac.    ..c.c.
..adc.    ..bdc.


`,'1 combination - 3 elements - height 2 - 4', `
......    ......
......    ......
......    ......
......    ......
......    ......
..aac.    ..c.c.
..adc.    ..bdc.

`,'1 combination - 3 elements - height 2 - 5', `
......    ......
......    ......
......    ......
......    ......
......    ......
..aca.    ..aca.
..adc.    ..adc.

`,'1 combination - 3 elements - height 3 - 1', `
......    ......
......    ......
......    ......
......    ......
a.....    ......
a.....    ......
a.....    b.....

`,'1 combination - 3 elements - height 3 - 1', `
......    ......
......    ......
......    ......
......    ......
a.....    ......
a.....    ......
a.....    b.....

`,'1 combination - 3 elements - height 3 - 2', `
......    ......
......    ......
a.....    ......
a.....    ......
a.....    b.....
d.....    d.....
d.....    d.....


`,'1 combination - 4 elements - height 1 - 1', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
bbbb..    c.....


`,'1 combination - 5 elements - height 1 - 1', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
.bbbbb    .c....


`,'1 combination - 6 elements - height 1 - 1', `
......    ......
......    ......
......    ......
......    ......
......    ......
......    ......
bbbbbb    c.....

`];


describe.each(extract_input_output_boards(na3_data.slice(0,12))
)('title: %s', (title, input, output) => {
        test('=>', () => {
            expect(updated_board(input)).toStrictEqual(output);
        });
    }
);

